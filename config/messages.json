[
    {"role": "user", "content": "Calculate the fraud detection rate (alerts/transactions) by portfolio and customer segment to identify potential gaps in our detection models."},
    {"role": "assistant", "content": "WITH transactions AS (SELECT customer_portfolio_type AS portfolio_type, customer_portfolio_class AS segment, COUNT(*) AS transaction_count FROM event_store GROUP BY portfolio_type, segment), alerts AS (SELECT id.payload.schema.customer_portfolio_type AS portfolio_type, id.payload.schema.customer_portfolio_class AS segment, COUNT(*) AS alert_count FROM cm_event_arrival WHERE alert = TRUE GROUP BY portfolio_type, segment) SELECT t.portfolio_type, t.segment, t.transaction_count, a.alert_count, ROUND(a.alert_count / t.transaction_count * 100, 2) AS detection_rate FROM transactions t LEFT JOIN alerts a ON t.portfolio_type = a.portfolio_type AND t.segment = a.segment ORDER BY detection_rate;"},
  
    {"role": "user", "content": "Quantify the financial impact of delayed fraud detection by comparing the timestamp differences between transaction creation and fraud confirmation."},
    {"role": "assistant", "content": "WITH fraud_confirmations AS (SELECT e.lifecycle_id, e.sender_transaction_amount, e.sender_transaction_currency, TIMESTAMP_MILLIS(e.created_at) AS creation_time, MIN(TIMESTAMP_MILLIS(s.updatedAt)) AS confirmation_time FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier WHERE e.outcome_fraud = TRUE AND s.state.id IN ('STATE-FRAUD-CONFIRMED') GROUP BY e.lifecycle_id, e.sender_transaction_amount, e.sender_transaction_currency, e.created_at) SELECT CASE WHEN TIMESTAMP_DIFF(confirmation_time, creation_time, HOUR) < 1 THEN 'Under 1 hour' WHEN TIMESTAMP_DIFF(confirmation_time, creation_time, HOUR) < 4 THEN '1-4 hours' WHEN TIMESTAMP_DIFF(confirmation_time, creation_time, HOUR) < 24 THEN '4-24 hours' ELSE 'Over 24 hours' END AS detection_time_bucket, COUNT(*) AS fraud_cases, SUM(sender_transaction_amount) AS total_amount, AVG(sender_transaction_amount) AS avg_fraud_amount, sender_transaction_currency FROM fraud_confirmations GROUP BY detection_time_bucket, sender_transaction_currency ORDER BY CASE WHEN detection_time_bucket = 'Under 1 hour' THEN 1 WHEN detection_time_bucket = '1-4 hours' THEN 2 WHEN detection_time_bucket = '4-24 hours' THEN 3 ELSE 4 END;"},
  
    {"role": "user", "content": "Create a heat map of fraud by time-of-day and day-of-week to optimize analyst staffing patterns for peak fraud periods."},
    {"role": "assistant", "content": "SELECT FORMAT_TIMESTAMP('%A', TIMESTAMP_MILLIS(created_at)) AS day_of_week, EXTRACT(HOUR FROM TIMESTAMP_MILLIS(created_at)) AS hour_of_day, COUNT(*) AS fraud_count FROM event_store WHERE outcome_fraud = TRUE GROUP BY day_of_week, hour_of_day ORDER BY CASE day_of_week WHEN 'Monday' THEN 1 WHEN 'Tuesday' THEN 2 WHEN 'Wednesday' THEN 3 WHEN 'Thursday' THEN 4 WHEN 'Friday' THEN 5 WHEN 'Saturday' THEN 6 WHEN 'Sunday' THEN 7 END, hour_of_day;"},
  
    {"role": "user", "content": "Compare fraud outcomes between push-notification eligible customers versus non-eligible customers to measure the effectiveness of our customer engagement strategy."},
    {"role": "assistant", "content": "WITH events_with_eligibility AS (SELECT e.lifecycle_id, e.event_type, e.outcome_fraud, e.sender_transaction_amount, CASE WHEN p.lifecycle_id IS NOT NULL THEN TRUE ELSE FALSE END AS push_eligible FROM event_store e LEFT JOIN (SELECT DISTINCT ids[OFFSET(0)].identifier AS lifecycle_id FROM cm_event_state_updates WHERE ids[OFFSET(0)].payload.schema.treatment_strategy LIKE '%PUSH%') p ON e.lifecycle_id = p.lifecycle_id WHERE e.event_type IN ('PAYMENT_FAILED', 'FRAUD_SUSPECTED')) SELECT push_eligible, COUNT(*) AS total_events, COUNT(CASE WHEN outcome_fraud = TRUE THEN 1 END) AS confirmed_fraud, ROUND(COUNT(CASE WHEN outcome_fraud = TRUE THEN 1 END) / COUNT(*) * 100, 2) AS fraud_rate, SUM(CASE WHEN outcome_fraud = TRUE THEN sender_transaction_amount ELSE 0 END) AS total_fraud_amount, AVG(CASE WHEN outcome_fraud = TRUE THEN sender_transaction_amount ELSE NULL END) AS avg_fraud_amount FROM events_with_eligibility GROUP BY push_eligible;"},
  
    {"role": "user", "content": "Identify which types of confirmed fraud have the highest average transaction values, helping prioritize rule development for high-impact fraud scenarios."},
    {"role": "assistant", "content": "SELECT event_type, COUNT(*) AS fraud_count, AVG(sender_transaction_amount) AS avg_fraud_amount, MAX(sender_transaction_amount) AS max_fraud_amount, SUM(sender_transaction_amount) AS total_fraud_amount, sender_transaction_currency FROM event_store WHERE outcome_fraud = TRUE GROUP BY event_type, sender_transaction_currency HAVING COUNT(*) >= 5 ORDER BY avg_fraud_amount DESC;"},
  
    {"role": "user", "content": "Calculate the ratio of false positives by queue and analyst to identify potential training opportunities or rule recalibration needs."},
    {"role": "assistant", "content": "WITH analyst_decisions AS (SELECT s.username AS analyst, q.queueId AS queue, COUNT(*) AS total_reviews, COUNT(CASE WHEN e.outcome_fraud = TRUE THEN 1 END) AS true_positives, COUNT(CASE WHEN e.outcome_fraud = FALSE THEN 1 END) AS false_positives FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier JOIN cm_event_queue_changed q ON e.lifecycle_id = q.ids[OFFSET(0)].identifier WHERE s.state.id IN ('STATE-RESOLVED', 'STATE-CLOSED') GROUP BY analyst, queue HAVING total_reviews >= 10) SELECT analyst, queue, total_reviews, true_positives, false_positives, ROUND(false_positives / NULLIF(total_reviews, 0) * 100, 2) AS false_positive_rate FROM analyst_decisions ORDER BY false_positive_rate DESC;"},
  
    {"role": "user", "content": "Extract all confirmed fraud cases handled by remote banking teams in January where the transaction amount exceeded £10,000, including customer segment and fraud type."},
    {"role": "assistant", "content": "SELECT e.lifecycle_id, e.event_type, e.customer_portfolio_type, e.customer_portfolio_class AS customer_segment, e.sender_transaction_amount, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, q.queueId AS handling_queue FROM event_store e JOIN cm_event_queue_changed q ON e.lifecycle_id = q.ids[OFFSET(0)].identifier WHERE e.outcome_fraud = TRUE AND e.sender_transaction_amount > 10000 AND e.sender_transaction_currency = 'GBP' AND q.queueId IN ('QUEUE-REMOTE', 'QUEUE-DIGITAL') AND FORMAT_TIMESTAMP('%Y-%m', TIMESTAMP_MILLIS(e.created_at)) = '2025-01' ORDER BY e.sender_transaction_amount DESC;"},
  
    {"role": "user", "content": "Show me all cases where customers confirmed fraud via mobile messaging within 1 hour of transaction initiation, including transaction details and device information."},
    {"role": "assistant", "content": "SELECT e.lifecycle_id, e.event_type, e.customer_id, e.customer_name, e.sender_transaction_amount, e.sender_transaction_currency, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, s.username AS confirmed_by, TIMESTAMP_MILLIS(s.updatedAt) AS confirmation_time, TIMESTAMP_DIFF(TIMESTAMP_MILLIS(s.updatedAt), TIMESTAMP_MILLIS(e.created_at), MINUTE) AS minutes_to_confirm, e.device_type, e.device_os, e.device_ip_address FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier WHERE s.state.id = 'STATE-FRAUD-CONFIRMED' AND s.note LIKE '%via mobile messaging%' AND TIMESTAMP_DIFF(TIMESTAMP_MILLIS(s.updatedAt), TIMESTAMP_MILLIS(e.created_at), MINUTE) <= 60 ORDER BY minutes_to_confirm;"},
  
    {"role": "user", "content": "Provide a list of all international payment fraud cases involving First Direct customers where the customer was successfully contacted through push notifications."},
    {"role": "assistant", "content": "SELECT e.lifecycle_id, e.event_type, e.customer_id, e.customer_name, e.sender_transaction_amount, e.sender_transaction_currency, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, REGEXP_EXTRACT(s.note, r'contacted via ([^\\s]+)') AS contact_method FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier WHERE e.outcome_fraud = TRUE AND e.customer_portfolio_country = 'FD' AND (e.event_type LIKE '%INTERNATIONAL%' OR e.event_type LIKE '%FOREIGN%' OR REGEXP_CONTAINS(e.lifecycle_id, r'GFX')) AND s.note LIKE '%push notification%' AND s.note LIKE '%success%' ORDER BY e.sender_transaction_amount DESC;"},
  
    {"role": "user", "content": "Generate a summary of fraud cases where the customer initially disputed but later confirmed the transaction was genuine, grouped by customer segment and channel."},
    {"role": "assistant", "content": "WITH state_sequence AS (SELECT e.lifecycle_id, e.customer_portfolio_type, e.customer_portfolio_class, e.customer_portfolio_channel, ARRAY_AGG(s.state.id ORDER BY s.updatedAt) AS states, ARRAY_AGG(s.note ORDER BY s.updatedAt) AS notes FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier GROUP BY e.lifecycle_id, e.customer_portfolio_type, e.customer_portfolio_class, e.customer_portfolio_channel) SELECT customer_portfolio_type, customer_portfolio_class AS segment, customer_portfolio_channel AS channel, COUNT(*) AS case_count FROM state_sequence WHERE (SELECT COUNT(1) FROM UNNEST(states) state WHERE state = 'STATE-DISPUTED') > 0 AND (SELECT COUNT(1) FROM UNNEST(states) state WHERE state = 'STATE-GENUINE') > 0 AND (SELECT MAX(offset) FROM UNNEST(states) state WITH OFFSET WHERE state = 'STATE-GENUINE') > (SELECT MAX(offset) FROM UNNEST(states) state WITH OFFSET WHERE state = 'STATE-DISPUTED') GROUP BY customer_portfolio_type, segment, channel ORDER BY case_count DESC;"},
  
    {"role": "user", "content": "Identify all high-value business banking payments that triggered alerts but were later approved, including beneficiary details and rule triggers."},
    {"role": "assistant", "content": "SELECT e.lifecycle_id, e.event_type, e.customer_id, e.sender_transaction_amount, e.sender_transaction_currency, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, a.id.payload.schema.alert_id AS alert_id, s.state.id AS final_state, s.username AS approved_by, TIMESTAMP_MILLIS(s.updatedAt) AS approval_time, e.receiver_transaction_amount AS beneficiary_amount, e.receiver_transaction_currency AS beneficiary_currency, REGEXP_EXTRACT(w.name, r'([^\\s]+)') AS rule_triggered FROM event_store e JOIN cm_event_arrival a ON e.lifecycle_id = a.id.identifier JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier LEFT JOIN workflow_rules_vw w ON e.event_type = REGEXP_EXTRACT(w.condition, r'event_type == \"([^\"]+)\"') AND e.customer_portfolio_type = REGEXP_EXTRACT(w.condition, r'customer_portfolio_type == \"([^\"]+)\"') WHERE e.customer_portfolio_class = 'BUSINESS' AND e.sender_transaction_amount > 50000 AND a.alert = TRUE AND s.state.id = 'STATE-APPROVED' ORDER BY e.sender_transaction_amount DESC;"},
  
    {"role": "user", "content": "Create a report showing the time gap between alert generation and analyst review for fraud cases exceeding £5,000, segmented by portfolio and time of day."},
    {"role": "assistant", "content": "WITH alerts AS (SELECT e.lifecycle_id, e.customer_portfolio_type, e.customer_portfolio_country AS portfolio, e.sender_transaction_amount, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, a.timestamp AS alert_time, EXTRACT(HOUR FROM TIMESTAMP(a.timestamp)) AS alert_hour FROM event_store e JOIN cm_event_arrival a ON e.lifecycle_id = a.id.identifier WHERE e.outcome_fraud = TRUE AND e.sender_transaction_amount > 5000 AND e.sender_transaction_currency = 'GBP' AND a.alert = TRUE), reviews AS (SELECT s.ids[OFFSET(0)].identifier AS lifecycle_id, MIN(TIMESTAMP_MILLIS(s.updatedAt)) AS first_review_time FROM cm_event_state_updates s WHERE s.stateMachineId = 'SM-REVIEW' GROUP BY s.ids[OFFSET(0)].identifier) SELECT a.portfolio, a.alert_hour, COUNT(*) AS case_count, AVG(TIMESTAMP_DIFF(r.first_review_time, TIMESTAMP(a.alert_time), MINUTE)) AS avg_review_gap_minutes, MIN(TIMESTAMP_DIFF(r.first_review_time, TIMESTAMP(a.alert_time), MINUTE)) AS min_review_gap_minutes, MAX(TIMESTAMP_DIFF(r.first_review_time, TIMESTAMP(a.alert_time), MINUTE)) AS max_review_gap_minutes, AVG(a.sender_transaction_amount) AS avg_transaction_amount FROM alerts a JOIN reviews r ON a.lifecycle_id = r.lifecycle_id GROUP BY a.portfolio, a.alert_hour ORDER BY a.portfolio, a.alert_hour;"},
  
    {"role": "user", "content": "Compile a list of all confirmed impersonation scam cases for elderly customers, including transaction amount, channel, and time to fraud confirmation."},
    {"role": "assistant", "content": "WITH elderly_customers AS (SELECT customer_id FROM event_store WHERE customer_segment = 'ELDERLY' OR customer_portfolio_class = 'SENIOR'), impersonation_cases AS (SELECT e.lifecycle_id, e.customer_id, e.customer_name, e.event_type, e.customer_portfolio_channel AS channel, e.sender_transaction_amount, e.sender_transaction_currency, TIMESTAMP_MILLIS(e.created_at) AS transaction_time, s.state.id, s.note, TIMESTAMP_MILLIS(s.updatedAt) AS confirmation_time FROM event_store e JOIN cm_event_state_updates s ON e.lifecycle_id = s.ids[OFFSET(0)].identifier JOIN elderly_customers ec ON e.customer_id = ec.customer_id WHERE e.outcome_fraud = TRUE AND s.state.id = 'STATE-FRAUD-CONFIRMED' AND (s.note LIKE '%impersonation%' OR e.event_type LIKE '%IMPERSONATION%' OR s.note LIKE '%posed as%')) SELECT lifecycle_id, customer_id, customer_name, event_type, channel, sender_transaction_amount, sender_transaction_currency, transaction_time, confirmation_time, TIMESTAMP_DIFF(confirmation_time, transaction_time, MINUTE) AS minutes_to_confirm, note FROM impersonation_cases ORDER BY sender_transaction_amount DESC;"}
  ]